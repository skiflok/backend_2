# ShopAPI

* Тематика магазина: магазин бытовой техники.

## Запуск

<details>
  <summary>Описание команд запуска</summary>

* `sudo nano /etc/hosts`
* add `127.0.0.1   s21backend` добавляем локальный DNS
* `sudo openssl req -x509 -nodes -days 7 -newkey rsa:2048 \
  -keyout ./src/main/resources/cert/s21backend.key \
  -out ./src/main/resources/cert/s21backend.crt` создаем самоподписный сертификат
* Common Name указать `s21backend`
* `mvn clean install -DskipTests -X` установка в локальный репозиторий
* `mvn jib:dockerBuild` создание образа докер с помощью jib
* `docker compose up` запуск контейнеров
* `docker compose dowm` остановка контейнеров

</details>

### пересборка имейджа

<details>
  <summary>rebuild</summary>

* `docker compose down`
* `mvn clean install`
* `docker rmi backend`
* `mvn jib:dockerBuild`

</details>

## versions history

<details>
  <summary>Описание изменений версий</summary>

* v0.1.0 реализован основной функционал + апи + сваггер, postgress в докере
* v1.0.0 приложение перенесено в контейнер, сборка image через JIB
* v1.1.0 Добавлен NGINX. Реализован реверс прокси (прямой доступ к порту контейнера и бд оставлен для отладки).
  Маршрутизация /api -> на /api/v1
* v1.2.0 По пути /api/v1 отдается swagger.
* v1.3.0 раздача статики на /.
* v1.4.0 настроен pgAdmin на /admin.
* v1.5.0 статус nginx на /status.
* v1.6.0 Добавлено 2 инстанса бэкенда с правами доступа в базу данных только на чтение и настроена
  балансировка GET запросов к /api/v1 в NGINX на 3 бэкенда в соотношении 2:1:1, где первый — основной
  бэкенд-сервер.
* v1.7.0 Настроено кеширование GET запросов, кроме /api.
* v1.8.0 Настроено gzip-сжатие в Nginx. Сжатие не распространяется на медиа-типы (jpeg, png и т. д.).
* v1.9.0 Настроен ssl протокол (нужно сгенерить сертификат)

> В связи с тем что добавлен `auth-service` добавлен как модуль в общий репозиторий,
> дальнейшее версионирование тегов будет привязано к сервису
> например auth-v1.0.0

* auth-v1.0.0 Реализован сервис аутентификации пользователей по протоколу gRPC
    - регистрация пользователя(возвращает токен), проверка пользователя, изменение и восстановление пароля
    - сервис хранит данные в своем хранилище PSQL (пароли в захэшированном виде с солью)
* auth-v1.1.0 Добавлен метод валидации токена, небольшие фиксы
* shop-v2.0.0
    - Добавлены методы регистрации (/register), авторизации(/auth), восстановления пароля(/reset)
    - Авторизация ручек всех API на основе верификации в сервисе аутентификации.

</details>

## Swagger

<details>
  <summary>вызовы сваггера через реверс прокси</summary>

* http://localhost/api/v1
* http://localhost/docs
* http://localhost/docs/swagger-config

</details>

## Сущности

<details>
  <summary>Описание сущностей</summary>

```
// Клиент
client
{
    id
    client_name
    client_surname
    birthday
    gender
    registration_date
    address_id
}
```

```
// Товар
product
{
    id
    name
    category
    price
    available_stock // число закупленных экземпляров товара
    last_update_date // число последней закупки
    supplier_id
    image_id: UUID
}
```

```
// Поставщики
supplier
{
    id
    name
    address_id
    phone_number
}
```

```
// Изображения товаров
images
{
    id : UUID
    image: bytea
}
```

```
// Адреса

address 
{
    id
    country
    city
    street
}
```

</details>

## Реализованы виды HTTP запросов (GET, POST, PUT, DELETE, PATCH).

<details>
  <summary>Описание API</summary>

Реализованы HTTP запросы (GET, POST, PUT, DELETE, PATCH).

- Для клиентов:

    1) Добавление клиента (на вход подается json, соответствующей структуре, описанной сверху).

    2) Удаление клиента (по его идентификатору)

    3) Получение клиентов по имени и фамилии (параметры - имя и фамилия)

    4) Получение всех клиентов (В данном запросе необходимо предусмотреть опциональные параметры пагинации в строке
       запроса: limit и offset). В случае отсутствия эти параметров возвращать весь список.

    5) Изменение адреса клиента (параметры: Id и новый адрес в виде json в соответствии с выше описанным форматом)

- Для товаров:

    1) Добавление товара (на вход подается json, соответствующей структуре, описанной сверху).

    2) Уменьшение количества товара (на вход запросу подается id товара и на сколько уменьшить)

    3) Получение товара по id

    4) Получение всех доступных товаров

    5) Удаление товара по id

- Для поставщиков:

    1) Добавление поставщика (на вход подается json, соответствующей структуре, описанной сверху).

    2) Изменение адреса поставщика (параметры: Id и новый адрес в виде json в соответствии с выше описанным форматом)

    3) Удаление поставщика по id

    4) Получение всех поставщиков

    5) Получение поставщика по id

- Для изображений:

    1) добавление изображения (на вход подается byte array изображения и id товара).

    2) Изменение изображения (на вход подается id изображения и новая строка для замены)

    3) Удаление изображения по id изображения

    4) Получение изображения конкретного товара (по id товара)

    5) Получение изображения по id изображения

</details>

## Swagger спецификация

> http://localhost:9999/swagger/index.html

## NGINX реверс прокси, балансировка запросов, сжатие, кэширование, https

<details>
<summary>реализовано по nginx</summary>

- [x] Настроить обратное проксирование на порт своего приложения.


- [x] Настроить Nginx для работы web-приложения в части маршрутизации:
    - [x] Настроить маршрутизацию /api -> на /api/v1.
    - [x] По пути /api/v1 выдавать swagger.
    - [x] Настроить раздачу статики по пути /. В корне раздачи статики поместить 2 файла: index.html и image.png.
    - [x] Настроить /admin на pgAdmin — GUI СУБД POSTGRES.
    - [x] Настроить /status на отдачу страницы статуса сервера Nginx (nginx status).


- [x] Настроить Nginx в части балансировки:

    - [x] Запустить еще 2 инстанса бэкенда на других портах с правами доступа в базу данных только на чтение и настроить
      балансировку GET запросов к /api/v1 (/api/v2) в NGINX на 3 бэкенда в соотношении 2:1:1, где первый — основной
      бэкенд-сервер.


- [x] Настроить кеширование (для всех GET-запросов, кроме /api).


- [x] Настроить gzip-сжатие в Nginx. Сжатие не должно распространяться на медиа-типы (jpeg, png и т. д.).

- [x] Настроить HTTPS на локальном устройстве.

    - [x] Создать доменное имя в локальном DNS-сервере. У каждого компьютера есть локальное DNS-хранилище, в котором
      можно прописать собственное название сайта и по какому адресу этот адрес резолвится.

    - [x] Создать самоподписанный сертификат с использованием openssl для созданного доменного имени и привязать его в
      Nginx-конфиге.

    - [x] Настроить reverse proxy на запущенное приложение.

</details>

## Авторизация с помощью сервиса авторизации по gRPC

<details>
<summary>разработано по авторизации</summary>

- [x] Если в блоке 2 не был использован паттерн Dependency injection,
  то в этом блоке он обязательно должен быть.
  Реализуйте прокидывание реализаций, используя интерфейсы через IOC-контейнер.

- [x] Необходимо реализовать сервис авторизации (отдельное приложение),
  используя который можно будет аутентифицировать и авторизовать пользователей для магазина бытовой техники.
    - [x] Сервис авторизации должен иметь своё хранилище (PostgreSQL).
      Для этого создаёте новую базу данных и прокидываете строку подключения внутрь своего сервиса (Не новая таблица, а
      новая база!).
    - [x] Сервис авторизации должен предоставлять взаимодействие только лишь посредством протокола gRPC.
      Настройте его в качестве gRPC сервера, опишите .proto файл, с описанием предоставляемых методов.
    - [x] Сервис авторизации должен предоставлять следующие методы:
        - [x] Создание пользователя по входным данным (почта, имя, фамилия, номер телефона, пароль), возвращает
          подписанный токен.
            - [x] Необходимо соблюсти один из важнейших принципов компьютерной безопасности: система не должна хранить
              пароли своих пользователей в открытом виде.
              Пароли в базе необходимо хранить в захэшированном виде с солью (произвольной сконкатенированной до
              хэширования строкой).
              Также нельзя брать устаревшие и имеющие уязвимости алгоритмы хэширования md5 и sha1.
              Таким образом, даже если ваша база данных попадет в руки злоумышленников, они не узнают реальные пароли,
              которыми пользуются ваши клиенты.
        - [x] Проверка пары логин-пароль (аутентифицировать пользователя), возвращает токен.
        - [x] Изменение пароля пользователя
        - [x] Метод восстановления пароля: Отправки пароля на почту пользователя
          Саму отправку на почту реализовывать не нужно.
          Вместо этого, реализовать заглушку отправки на почту в виде вывода пароля в консоль сервиса авторизации.


- [x] Добавить метод регистрации (/register), авторизации(/auth), восстановления пароля(/reset) для магазина бытовой
  техники.
  Данные методы не подвергаются аутентификации, а всего лишь ходят в сервис авторизации для проверки или создания
  данных.


- [x] Реализовать авторизацию ручек всех API на основе верификации в сервисе аутентификации.
  Для аутентификации пользователя необходимо ходить в сервис авторизации и подтверждать валидность токена.
  Если токен валиден, то метод доступен, если нет - возвращать 401.
    - [x] Авторизацию в методах контроллера необходимо сделать на основе самописного атрибута авторизации, логика
      обработки которого лежит в middleware приложения.
      Т.е. прежде чем пустить запрос в обработчик, необходимо аутенцифицировать пользователя.
    - [x] JWT токен необходимо передавать в Authorization header.

</details>

## TODO

- [ ] Необходимо написать сервис-генератор событий об изменении атрибутов товара (стоимости и остаточном количестве).
    * Сервис представляет собой некий worker, который по таймеру будет брать рандомный товар, менять у него значения
      полей. Это и есть генерируемое событие по таймауту.

- [ ]  События должны посылаться на gateway нашего приложения (API),
  который должен обновить информацию о товаре в базе и
  обновить эту же информацию у клиентов по WebSockets и SSE:
    * Нужно реализовать простенькие эхо-клиенты (WebSockets и SSE) на JavaScript, которые будут получать обновлённую
      информацию о товаре и выводить информацию в консоль.

- [ ]  Доставка сообщений должна происходить в gateway через брокер сообщений (RabbitMQ или Apache Kafka).

- [ ]  Фотографии товара для ответов должны кешироваться в Redis.