# reactor vs emitter

Ниже сравним два подхода к реализации SSE в вашем Event-сервисе:

| Характеристика              | WebFlux + Reactor Sinks                                        | Spring MVC + SseEmitter                                     |
|-----------------------------|----------------------------------------------------------------|-------------------------------------------------------------|
| Зависимости                 | spring-boot-starter-webflux                                    | spring-boot-starter-web                                     |
| Встроенный сервер           | Netty (по умолчанию)                                           | Tomcat/Jetty (по умолчанию)                                 |
| Модель программирования     | Реактивная (Flux, Sinks)                                       | Блокирующая (нити, SseEmitter)                              |
| Производительность          | Высокая при большом числе коннекций (NIO-event loop)           | Хорошая, но каждой коннекции соответствует выделенный поток |
| Потребление памяти          | Низкое (один EventLoop на сотни/тысячи соединений)             | Выше (каждый клиент ≈ один поток / ServletContext)          |
| Простота кода               | Немного сложнее: реактивные API, проект Reactor                | Проще: почти "из коробки" с SseEmitter                      |
| Backpressure / буфер        | Встроенная поддержка (Sinks, Flux.backpressure)                | Нужно вручную управлять списками и таймаутами               |
| Обработка ошибок            | Реактивные операторы (retry, onErrorContinue)                  | WebMvc исключения, кастомные HandlerExceptionResolver       |
| Возможность масштабирования | Отлично масштабируется на EventLoop-модель                     | Требует больше памяти при горизонтальном масштабировании    |
| Готовность к будущему       | Легче добавить другие реактивные интеграции (WebClient, R2DBC) | Остаётесь в классическом стеке                              |

---

### Когда выбрать WebFlux + Reactor Sinks

* Ты ожидаешь десятки тысяч одновременно открытых SSE-коннекций.
* Хочешь реактивную архитектуру сквозь весь стек (WebClient, драйвер БД, Kafka Reactor).
* Требуется Built-in backpressure и контроль потока сообщений.
* Готов чуть больше потратить времени на освоение Reactor API.

### Когда выбрать Spring MVC + SseEmitter

* У тебя сотни–тысячи клиентов, и этого достаточно.
* Ты уже используешь классический стек (JPA, RestController) и не хочешь добавлять WebFlux.
* Нужна максимальная простота: минимум кода для проброса событий.
* Памяти на инстансах хватает, и ты не стремишься к сотням тысяч коннекций.

---

## Рекомендация

* Для высоких нагрузок (10 000+ SSE-клиентов на одном инстансе) — WebFlux + Reactor Sinks.
* Для простых кейсов (≤ 5 000–8 000 клиентов) и если ты не хочешь менять стек — Spring MVC + SseEmitter.

Если в будущем ты планируешь добавлять и другие реактивные компоненты (Reactor Kafka, R2DBC, WebClient), имеет смысл
сразу перейти на WebFlux. В противном случае, для минимальной сложности, оставайся на SseEmitter.