## Проблемы по миграции

### Не загружает изображеиня через миграцию

Проблема, с которой вы столкнулись, связана с тем, что функция  `pg_read_binary_file`  ожидает путь к файлу в файловой системе PostgreSQL, а не в файловой системе Windows. Когда вы используете эту функцию, PostgreSQL должен иметь доступ к указанному файлу, и путь должен быть правильным.

Вот несколько шагов, которые могут помочь вам решить эту проблему:

1. **Путь к файлу**: Убедитесь, что вы указали правильный путь к файлу. Путь должен быть абсолютным и соответствовать файловой системе сервера PostgreSQL, а не клиентского компьютера. Если PostgreSQL работает на локальной машине, убедитесь, что файл доступен по указанному пути.

2. **Права доступа**: Убедитесь, что у пользователя, под которым работает PostgreSQL, есть права доступа к файлу. PostgreSQL должен иметь возможность читать файл.

3. **Использование  `pg_read_binary_file` **: Если вы используете  `pg_read_binary_file` , убедитесь, что вы передаете правильный путь к файлу. Например:
   INSERT INTO s21.image (id, image)
   VALUES (gen_random_uuid(), pg_read_binary_file('C:/path/to/your/file'));
4. **Логирование ошибок**: Проверьте логи PostgreSQL на наличие ошибок, связанных с доступом к файлу. Это может дать вам подсказки о том, что именно пошло не так.

5. **Альтернативный способ загрузки данных**: Если вы не можете использовать  `pg_read_binary_file` , вы можете рассмотреть возможность загрузки данных в таблицу через другие методы, например, используя  `COPY`  из CSV или других форматов, или загружая данные через приложение, используя Spring Data JPA.

Если вы все еще сталкиваетесь с проблемами, пожалуйста, предоставьте дополнительные детали, и я постараюсь помочь вам дальше.

#### постгресс работает в докер контейнере а файл локально, предложи оптимальный вариан загрузки файла в бд через миграцию в таких условиях

Если PostgreSQL работает в Docker-контейнере, а файл находится на вашей локальной машине, вам нужно будет сначала переместить файл в контейнер, чтобы PostgreSQL смог его прочитать. Вот несколько подходов, как это можно сделать:

### 1. Копирование файла в контейнер

Вы можете использовать команду  `docker cp`  для копирования файла из локальной файловой системы в контейнер. Например:
docker cp /path/to/local/file <container_id>:/path/in/container/file
После того как файл будет скопирован в контейнер, вы сможете использовать  `pg_read_binary_file`  в вашей миграции:
INSERT INTO s21.image (id, image)
VALUES (gen_random_uuid(), pg_read_binary_file('/path/in/container/file'));
### 2. Использование Docker Volume

Если вы хотите, чтобы файл был доступен в контейнере без необходимости его копирования каждый раз, вы можете использовать Docker volume или монтирование директории. Например, при запуске контейнера вы можете смонтировать локальную директорию в контейнер:
docker run -v /path/to/local/directory:/path/in/container -e POSTGRES_PASSWORD=mysecretpassword -d postgres
После этого файл будет доступен по указанному пути внутри контейнера, и вы сможете использовать его в миграциях так же, как и в предыдущем примере.

### 3. Альтернативные методы загрузки данных

Если вы не хотите копировать файлы, вы можете рассмотреть другие методы загрузки данных:

- **Использование  `COPY` **: Если у вас есть CSV-файл, вы можете использовать команду  `COPY`  для загрузки данных. Например:
  COPY s21.image (id, image) FROM '/path/in/container/file.csv' DELIMITER ',' CSV;
- **Загрузка через приложение**: Вы можете написать код на Java с использованием Spring Data JPA для загрузки данных в базу данных. Это может быть полезно, если данные нужно обрабатывать перед вставкой.

### 4. Использование SQL-скриптов в Liquibase

Если вы используете Liquibase, вы можете создать SQL-скрипт, который будет включать команды для вставки данных, и затем выполнить его через Liquibase. Например, вы можете создать файл  `changelog.sql` :
INSERT INTO s21.image (id, image)
VALUES (gen_random_uuid(), pg_read_binary_file('/path/in/container/file'));
И указать этот файл в вашем changelog Liquibase.

### Заключение

Выбор метода зависит от вашей конкретной ситуации и требований. Если вам нужно часто загружать файлы, возможно, стоит рассмотреть вариант с монтированием директории. Если это одноразовая операция, проще будет использовать  `docker cp` .



#### анонимные процедуры

Чтобы связать изображение и продукт в вашем SQL-запросе, вам нужно использовать идентификатор изображения ( `image_id` ), который был сгенерирован при вставке в таблицу  `s21.image` . Поскольку вы используете  `gen_random_uuid()`  для генерации UUID, вы можете сохранить этот UUID в переменной и использовать его в дальнейшем запросе.

Вот как это можно сделать с помощью PL/pgSQL, чтобы сохранить UUID изображения и использовать его при вставке продукта:

### Пример с использованием PL/pgSQL
DO $$
DECLARE
new_image_id UUID;
BEGIN
-- Вставка адресов
INSERT INTO s21.address (city, country, street)
VALUES ('Moscow', 'RUSSIA', 'qwerty'),
('Kazan', 'RUSSIA', 'asdfgh');

    -- Генерация нового UUID и вставка изображения
    new_image_id := gen_random_uuid();
    INSERT INTO s21.image (id, image)
    VALUES (new_image_id, pg_read_binary_file('/psql_map_folder/product_images/duck.PNG'));

    -- Вставка клиентов
    INSERT INTO s21.client (client_name,
                             client_surname,
                             birthday,
                             gender,
                             registration_date,
                             address_id)
    VALUES ('client 1', 'client_surname 1', '2000-10-11', 'MALE', '2022-09-05', 1),
           ('client 2', 'client_surname 2', '2001-12-15', 'FEMALE', '2022-09-06', 2);

    -- Вставка поставщика
    INSERT INTO s21.supplier ("name", address_id, phone_number)
    VALUES ('pppppp', 1, '8987654321');

    -- Вставка продукта с использованием сгенерированного image_id
    INSERT INTO s21.product ("name", "category", price, available_stock, last_update_date, supplier_id, image_id)
    VALUES ('duck', 'HOME_AND_GARDEN', 15, 5, '2024-10-15', 1, new_image_id);
END $;
### Объяснение:
1. **DO $ ... $**: Это блок PL/pgSQL, который позволяет выполнять анонимные процедуры.
2. **DECLARE**: Здесь вы объявляете переменную  `new_image_id`  типа UUID для хранения идентификатора изображения.
3. **BEGIN**: Начало блока выполнения.
4. **new_image_id := gen_random_uuid();**: Генерация нового UUID и сохранение его в переменной  `new_image_id` .
5. **INSERT INTO s21.image**: Вставка изображения с использованием сгенерированного UUID.
6. **INSERT INTO s21.product**: Вставка продукта с использованием сохраненного  `new_image_id` , что связывает продукт с изображением.

### Примечания:
- Убедитесь, что путь к файлу в  `pg_read_binary_file`  корректен и доступен в контексте выполнения SQL-запроса.
- Проверьте, что все таблицы и их поля существуют и имеют правильные типы данных.
- Если вы используете другие базы данных, возможно, вам нужно будет адаптировать код под их синтаксис.

Этот подход обеспечит консистентность между изображением и продуктом, связывая их через идентификатор изображения.